<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy 19th Birthday, Eva! üéÇ‚ú®</title>
    <style>
        :root {
            --cosmic-primary: #000428;
            --cosmic-secondary: #004e92;
            --cosmic-accent: #b794f6;
            --cosmic-glow: #9f7aea;
            --cosmic-text: #f0e6ff;
            --cosmic-pink: #ff6b9d;
            --cosmic-gold: #ffd89b;
            --scroll-progress: 0;
            --mouse-x: 50%;
            --mouse-y: 50%;
            --hue-shift: 0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(
                180deg, 
                hsl(223, calc(100% - var(--scroll-progress) * 20%), calc(8% + var(--scroll-progress) * 5%)),
                hsl(209, calc(100% - var(--scroll-progress) * 30%), calc(29% + var(--scroll-progress) * 10%))
            );
            min-height: 100vh;
            font-family: 'Georgia', serif;
            color: #ffffff;
            overflow-x: hidden;
            position: relative;
        }

        /* Performance Stats */
        .perf-stats {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            border-radius: 8px;
            z-index: 10000;
            pointer-events: none;
            opacity: 0.8;
            line-height: 1.6;
            border: 1px solid rgba(0, 255, 0, 0.3);
        }

        .perf-stats div {
            margin: 2px 0;
        }

        .perf-stats .metric {
            color: #00ff00;
        }

        .perf-stats .value {
            color: #ffff00;
            font-weight: bold;
        }

        .perf-stats .warning {
            color: #ff6b6b;
        }

        .perf-stats .good {
            color: #51cf66;
        }

        /* Entry Overlay */
        .entry-overlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(
                ellipse at var(--mouse-x) var(--mouse-y), 
                #1b2735 0%, 
                #090a0f 100%
            );
            z-index: 9999;
            display: grid;
            place-items: center;
            transition: opacity 2s cubic-bezier(0.4, 0, 0, 1), 
                        transform 2s cubic-bezier(0.4, 0, 0, 1);
            will-change: opacity, transform;
        }

        .entry-overlay.hidden {
            opacity: 0;
            transform: scale(1.05);
            pointer-events: none;
        }

        .entry-content {
            text-align: center;
            animation: breathe 4s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes breathe {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-15px) scale(1.02); }
        }

        .entry-title {
            font-size: clamp(1.5em, 4vw, 2.5em);
            margin-bottom: 20px;
            background: linear-gradient(
                90deg,
                var(--cosmic-text),
                var(--cosmic-accent),
                var(--cosmic-glow),
                var(--cosmic-accent),
                var(--cosmic-text)
            );
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 3s linear infinite;
            letter-spacing: 2px;
        }

        @keyframes shimmer {
            to { background-position: 200% center; }
        }

        .entry-subtitle {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 40px;
            font-style: italic;
        }

        .enter-button {
            padding: 15px 40px;
            font-size: 1.1em;
            background: transparent;
            border: 1px solid rgba(183, 148, 246, 0.3);
            color: rgba(255, 255, 255, 0.8);
            border-radius: 50px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            backdrop-filter: blur(10px);
        }

        .enter-button::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(
                circle at var(--mouse-x) var(--mouse-y),
                rgba(183, 148, 246, 0.2),
                transparent 70%
            );
            opacity: 0;
            transition: opacity 0.3s;
        }

        .enter-button:hover::after {
            opacity: 1;
        }

        .enter-button:hover {
            border-color: rgba(183, 148, 246, 0.6);
            color: white;
            transform: translateY(-2px);
        }

        /* Optimized Canvas Background */
        #starCanvas {
            position: fixed;
            inset: 0;
            z-index: -1;
            opacity: 0;
            transition: opacity 3s ease;
            will-change: transform;
            transform: translateZ(0);
        }

        #starCanvas.visible {
            opacity: 1;
        }

        /* Sparkle Canvas */
        #sparkleCanvas {
            position: fixed;
            inset: 0;
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transition: opacity 2s ease;
        }

        #sparkleCanvas.visible {
            opacity: 1;
        }

        /* Mouse Trail Canvas */
        #trailCanvas {
            position: fixed;
            inset: 0;
            z-index: 4;
            pointer-events: none;
            opacity: 0;
            transition: opacity 2s ease;
        }

        #trailCanvas.visible {
            opacity: 1;
        }

        /* Floating Orbs Canvas */
        #orbCanvas {
            position: fixed;
            inset: 0;
            z-index: 3;
            pointer-events: none;
            opacity: 0;
            transition: opacity 2s ease;
        }

        #orbCanvas.visible {
            opacity: 1;
        }

        /* Wish Lanterns Canvas */
        #lanternCanvas {
            position: fixed;
            inset: 0;
            z-index: 6;
            opacity: 0;
            transition: opacity 2s ease;
            cursor: pointer;
        }

        #lanternCanvas.visible {
            opacity: 1;
        }

        /* Birthday Cake Canvas */
        #cakeCanvas {
            position: fixed;
            inset: 0;
            z-index: 7;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s ease;
        }

        #cakeCanvas.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            position: relative;
            z-index: 10;
            opacity: 0;
            transform: translateY(30px);
            transition: all 1.5s cubic-bezier(0.22, 1, 0.36, 1);
        }

        .container.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* Header */
        h1 {
            font-size: clamp(1.8em, 5vw, 3em);
            text-align: center;
            margin-bottom: 20px;
            background: linear-gradient(
                135deg,
                var(--cosmic-text),
                var(--cosmic-accent),
                var(--cosmic-glow)
            );
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 30px rgba(159, 122, 234, 0.5));
            line-height: 1.3;
            opacity: 0;
            animation: fadeInScale 1s forwards 0.5s;
        }

        @keyframes fadeInScale {
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            from {
                opacity: 0;
                transform: scale(0.9) translateY(20px);
            }
        }

        /* Birthday Date Display */
        .birthday-date {
            text-align: center;
            margin: 20px auto 30px;
            padding: 15px 30px;
            max-width: 400px;
            background: linear-gradient(
                135deg,
                rgba(255, 255, 255, 0.03),
                rgba(255, 255, 255, 0.08)
            );
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0;
            animation: fadeInScale 1s forwards 0.6s;
        }

        .birthday-date .day {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(
                90deg,
                #ffd89b,
                var(--cosmic-accent),
                var(--cosmic-glow)
            );
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
        }

        .birthday-date .message {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
            font-style: italic;
        }

        /* Audio Container */
        .audio-container {
            text-align: center;
            margin: 30px auto;
            padding: 25px;
            max-width: 500px;
            background: linear-gradient(
                135deg,
                rgba(255, 255, 255, 0.02),
                rgba(255, 255, 255, 0.05)
            );
            border-radius: 20px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            position: relative;
            overflow: hidden;
            opacity: 0;
            animation: fadeInScale 1s forwards 0.7s;
        }

        .audio-container::before {
            content: '';
            position: absolute;
            inset: -50%;
            background: conic-gradient(
                from 0deg at 50% 50%,
                transparent,
                var(--cosmic-accent),
                transparent
            );
            animation: spin 20s linear infinite;
            opacity: 0.05;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .audio-label {
            display: block;
            margin-bottom: 5px;
            color: var(--cosmic-accent);
            font-style: italic;
            font-size: 1.1em;
            position: relative;
            z-index: 1;
        }

        .audio-subtitle {
            display: block;
            margin-bottom: 15px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9em;
            position: relative;
            z-index: 1;
        }

        .audio-visual {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 4px;
            height: 40px;
            margin: 20px 0;
            position: relative;
            z-index: 1;
        }

        .audio-bar {
            width: 4px;
            background: linear-gradient(
                to top,
                var(--cosmic-accent),
                var(--cosmic-glow)
            );
            border-radius: 2px;
            transform-origin: bottom;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .audio-bar.playing {
            animation: wave 1s ease-in-out infinite;
        }

        .audio-bar:nth-child(1) { height: 35%; animation-delay: 0ms; }
        .audio-bar:nth-child(2) { height: 55%; animation-delay: 100ms; }
        .audio-bar:nth-child(3) { height: 45%; animation-delay: 200ms; }
        .audio-bar:nth-child(4) { height: 70%; animation-delay: 300ms; }
        .audio-bar:nth-child(5) { height: 50%; animation-delay: 400ms; }
        .audio-bar:nth-child(6) { height: 60%; animation-delay: 500ms; }
        .audio-bar:nth-child(7) { height: 40%; animation-delay: 600ms; }

        @keyframes wave {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(1.5); }
        }

        /* Interactive Cake Section */
        .cake-section {
            text-align: center;
            margin: 50px auto;
            padding: 40px 20px;
            max-width: 600px;
            background: linear-gradient(
                135deg,
                rgba(255, 255, 255, 0.02),
                rgba(255, 255, 255, 0.05)
            );
            border-radius: 25px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            opacity: 0;
            animation: fadeInScale 1s forwards 0.9s;
        }

        .cake-title {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: var(--cosmic-accent);
            font-style: italic;
        }

        .cake-subtitle {
            font-size: 0.95em;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 20px;
        }

        .cake-container {
            width: 300px;
            height: 300px;
            margin: 20px auto;
            position: relative;
        }

        .cake-instruction {
            font-size: 0.9em;
            color: var(--cosmic-gold);
            font-style: italic;
            margin-top: 15px;
            opacity: 0.8;
        }

        /* Wish Lantern Section */
        .lantern-section {
            text-align: center;
            margin: 50px auto;
            padding: 30px 20px;
            max-width: 700px;
            opacity: 0;
            animation: fadeInScale 1s forwards 1.1s;
        }

        .lantern-title {
            font-size: 1.8em;
            margin-bottom: 15px;
            background: linear-gradient(
                90deg,
                var(--cosmic-pink),
                var(--cosmic-accent),
                var(--cosmic-gold)
            );
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .lantern-subtitle {
            font-size: 1em;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 20px;
            font-style: italic;
        }

        .lantern-display {
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* Poem Title */
        h2 {
            font-size: 1.8em;
            text-align: center;
            margin: 60px 0 30px;
            color: var(--cosmic-text);
            font-style: italic;
            letter-spacing: 2px;
            opacity: 0;
            animation: fadeInScale 1s forwards 1.3s;
        }

        /* Letter */
        .letter {
            background: linear-gradient(
                135deg,
                rgba(255, 255, 255, 0.02),
                rgba(255, 255, 255, 0.04)
            );
            border-radius: 25px;
            padding: 50px;
            margin: 30px 0;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
        }

        .letter::before {
            content: '';
            position: absolute;
            inset: -100%;
            background: radial-gradient(
                circle at var(--mouse-x) var(--mouse-y),
                rgba(138, 43, 226, 0.05),
                transparent 50%
            );
            pointer-events: none;
        }

        .letter p {
            line-height: 1.9;
            margin-bottom: 25px;
            font-size: 1.1em;
            color: var(--cosmic-text);
            position: relative;
            z-index: 1;
            opacity: 0;
            transform: translateY(20px);
        }

        .letter.visible p {
            animation: fadeUp 0.8s forwards;
        }

        @keyframes fadeUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .letter p:nth-child(1) { animation-delay: 0.1s; }
        .letter p:nth-child(2) { animation-delay: 0.2s; }
        .letter p:nth-child(3) { animation-delay: 0.3s; }
        .letter p:nth-child(4) { animation-delay: 0.4s; }
        .letter p:nth-child(5) { animation-delay: 0.5s; }
        .letter p:nth-child(6) { animation-delay: 0.6s; }
        .letter p:nth-child(7) { animation-delay: 0.7s; }
        .letter p:nth-child(8) { animation-delay: 0.8s; }
        .letter p:nth-child(9) { animation-delay: 0.9s; }

        .letter em {
            color: var(--cosmic-accent);
            font-style: normal;
            font-weight: 500;
            transition: all 0.3s;
        }

        .letter em:hover {
            color: white;
            text-shadow: 0 0 20px var(--cosmic-accent);
        }

        /* Birthday Wishes */
        .birthday-wishes {
            text-align: center;
            font-size: 1.5em;
            margin: 50px 0;
            font-weight: bold;
            background: linear-gradient(
                90deg,
                #ffd89b,
                var(--cosmic-accent),
                var(--cosmic-glow),
                var(--cosmic-accent),
                #ffd89b
            );
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 4s linear infinite;
            opacity: 0;
        }

        .birthday-wishes.visible {
            animation: fadeInScale 1s forwards, shimmer 4s linear infinite;
        }

        /* Wish Message Popup */
        .wish-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(
                135deg,
                rgba(183, 148, 246, 0.95),
                rgba(159, 122, 234, 0.95)
            );
            padding: 30px 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            z-index: 10001;
            max-width: 500px;
            text-align: center;
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: none;
        }

        .wish-message.show {
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        .wish-message-text {
            font-size: 1.2em;
            line-height: 1.6;
            color: white;
            margin-bottom: 20px;
        }

        .wish-message-close {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 25px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .wish-message-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        /* Responsive */
        @media (max-width: 768px) {
            h1 { font-size: 1.5em; }
            .letter { padding: 30px 20px; }
            .perf-stats {
                font-size: 8px;
                padding: 8px;
            }
            .cake-container {
                width: 250px;
                height: 250px;
            }
            .wish-message {
                max-width: 90%;
                padding: 25px 20px;
            }
        }

        @media print {
            * { animation: none !important; }
            .perf-stats { display: none; }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <!-- Performance Stats -->
    <div class="perf-stats" id="perfStats">
        <div><span class="metric">FPS:</span> <span class="value" id="fps">60</span></div>
        <div><span class="metric">Particles:</span> <span class="value" id="particleCount">0</span></div>
        <div><span class="metric">Memory:</span> <span class="value" id="memUsage">Loading...</span></div>
        <div><span class="metric">Vec2 Pool:</span> <span class="value" id="poolStats">0/0</span></div>
        <div><span class="metric">Mode:</span> <span class="value" id="renderMode">Init...</span></div>
        <div><span class="metric">Reduction:</span> <span class="value" id="reductionFactor">1.00</span></div>
    </div>

    <!-- Entry Overlay -->
    <div class="entry-overlay" id="entryOverlay">
        <div class="entry-content">
            <h2 class="entry-title">Eva's 19th Birthday ‚ú®</h2>
            <p class="entry-subtitle">A cosmic celebration just for you</p>
            <button class="enter-button">Enter & Celebrate</button>
        </div>
    </div>

    <!-- Optimized Canvas Layers -->
    <canvas id="starCanvas"></canvas>
    <canvas id="orbCanvas"></canvas>
    <canvas id="trailCanvas"></canvas>
    <canvas id="sparkleCanvas"></canvas>
    <canvas id="lanternCanvas"></canvas>
    <canvas id="cakeCanvas"></canvas>

    <!-- Wish Message Popup -->
    <div class="wish-message" id="wishMessage">
        <div class="wish-message-text" id="wishMessageText"></div>
        <button class="wish-message-close" onclick="closeWishMessage()">‚ú® Close ‚ú®</button>
    </div>

    <div class="container" id="mainContainer">
        <h1>Happy 19th Birthday, Eva! üéÇ‚ú®</h1>
        
        <!-- Birthday Date Display -->
        <div class="birthday-date">
            <div class="day">üéÇ Nineteen & Shining üéÇ</div>
            <div class="message">Today celebrates the day you came into this world</div>
        </div>
        
        <!-- Audio Player -->
        <div class="audio-container">
            <span class="audio-label">‚ô™ Pisces - Tony Ann (Piano Cover) ‚ô™</span>
            <span class="audio-subtitle">A melody for your special day</span>
            <div class="audio-visual" id="audioVisual">
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
            </div>
            <audio id="bgMusic" loop>
                <source src="Pisces - Tony Ann (Piano Cover).mp3" type="audio/mpeg">
                Your browser does not support the audio element.
            </audio>
        </div>

        <!-- Interactive Birthday Cake -->
        <div class="cake-section">
            <div class="cake-title">üéÇ Your Birthday Cake üéÇ</div>
            <div class="cake-subtitle">Click the candles to make a wish!</div>
            <div class="cake-container" id="cakeContainer"></div>
            <div class="cake-instruction">‚ú® Click each candle to light it, then blow them out with a click! ‚ú®</div>
        </div>

        <!-- Wish Lanterns Section -->
        <div class="lantern-section">
            <div class="lantern-title">üèÆ Wish Lanterns üèÆ</div>
            <div class="lantern-subtitle">Click the floating lanterns to reveal birthday wishes</div>
            <div class="lantern-display">
                (Look for the glowing lanterns floating across the screen above!)
            </div>
        </div>

        <h2>A Note for You, Eva</h2>

        <div class="letter" id="letter">
            <p>Eva, today marks nineteen years since you arrived on this planet, and while our paths have only recently crossed, I wanted this day to feel special‚Äîbecause <em>you deserve that</em>, regardless of circumstances.</p>

            <p>Birthdays can be complicated. I won't pretend to know the full weight of what you carry, the quietness of celebrating when those who should be here are absent, or the ache of milestones that feel lonely. But I do know this: your presence in this world <em>matters</em>. The fact that you're here, at nineteen, having weathered storms I can only begin to imagine‚Äîthat speaks to a strength that deserves recognition.</p>

            <p>We're still in the early chapters of knowing each other, still learning the contours of who the other person is. I won't claim to understand all your complexities or the full story written in the space between what's said and what's left unspoken. But even in these beginning stages, I can see glimpses of someone <em>remarkable</em>‚Äîsomeone who shows up despite the difficulty, someone who carries grace even when it would be easier to carry bitterness.</p>

            <p>Losing your mum, having your dad serving far away, navigating life without the safety net of close friendships‚Äîthese aren't small things. They're profound absences that reshape everything. And yet here you are. Still standing. Still moving forward. That resilience, Eva, even if you don't feel resilient most days‚Äîit's <em>real</em>, and it's worthy of celebration.</p>

            <p>I created this small corner of the internet because nineteen years of life shouldn't pass unmarked, uncelebrated. You might not have stacks of presents or a room full of people singing off-key, but you have this: someone newly in your orbit who sees you, who recognizes that your birthday matters, and who wanted to create something that says, "<em>I'm glad you exist.</em>"</p>

            <p>As you step into this next year, I hope you find moments of unexpected joy. I hope you discover new reasons to smile. I hope you encounter kindness in surprising places‚Äîand I hope you're gentle with yourself on the days when nineteen feels heavier than it should. You're doing better than you think, even when it doesn't feel that way.</p>

            <p>This might be a simple gesture from someone who's just beginning to know you, but it comes with genuine warmth. Whatever this next year holds for you, Eva, I hope it brings you <em>connection</em> where there's been isolation, <em>light</em> where there's been shadow, and <em>reasons to believe</em> that better things are possible‚Äîbecause they are, and you deserve to experience them.</p>

            <p>May nineteen be a year where you find your footing in new ways. May it bring you the friendships you've been missing, the peace you've been seeking, and the hope that tomorrow can be different than yesterday. You're not alone in this universe, even when it feels that way.</p>

            <p>Happy birthday, Eva. Here's to you‚Äîto your strength, your journey, and the person you're becoming. üåü</p>
        </div>

        <div class="birthday-wishes" id="birthdayWishes">
            Wishing you a year filled with new beginnings and unexpected beauty. ‚ú®üéÇüíú
        </div>
    </div>

    <script>
        'use strict';

        // ============================================================
        // OPTIMIZED COSMIC BIRTHDAY FOR EVA - FULLY FEATURED
        // ============================================================

        /**
         * Performance Monitor
         */
        const PerfMonitor = (() => {
            let frameCount = 0;
            let lastTime = performance.now();
            let fps = 60;
            const fpsHistory = new Float32Array(10);
            let historyIndex = 0;
            
            return Object.freeze({
                update: () => {
                    frameCount++;
                    const now = performance.now();
                    if (now >= lastTime + 1000) {
                        fps = Math.round((frameCount * 1000) / (now - lastTime));
                        fpsHistory[historyIndex] = fps;
                        historyIndex = (historyIndex + 1) % fpsHistory.length;
                        
                        frameCount = 0;
                        lastTime = now;
                        
                        const fpsEl = document.getElementById('fps');
                        if (fpsEl) fpsEl.textContent = fps;
                    }
                },
                getFPS: () => fps,
                getAvgFPS: () => {
                    let sum = 0;
                    let count = 0;
                    for (let i = 0; i < fpsHistory.length; i++) {
                        if (fpsHistory[i] > 0) {
                            sum += fpsHistory[i];
                            count++;
                        }
                    }
                    return count > 0 ? sum / count : 60;
                }
            });
        })();

        /**
         * Memory usage monitor
         */
        function getMemoryUsage() {
            if (performance.memory) {
                const used = Math.round(performance.memory.usedJSHeapSize / 1048576);
                const total = Math.round(performance.memory.totalJSHeapSize / 1048576);
                return `${used}/${total} MB`;
            }
            return 'N/A';
        }

        /**
         * Update performance stat display
         */
        function updatePerfStat(id, value, className = 'value') {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = value;
                el.className = className;
            }
        }

        /**
         * Immutable state container
         */
        const createState = (initialState) => {
            let state = Object.freeze({ ...initialState });
            const subscribers = new Set();
            
            return Object.freeze({
                get: () => state,
                
                update: (updater) => {
                    const newState = Object.freeze({
                        ...state,
                        ...(typeof updater === 'function' ? updater(state) : updater)
                    });
                    state = newState;
                    subscribers.forEach(fn => fn(newState));
                    return newState;
                },
                
                subscribe: (fn) => {
                    subscribers.add(fn);
                    return () => subscribers.delete(fn);
                },
                
                getField: (field) => state[field]
            });
        };

        /**
         * Vec2 class for 2D vector operations
         */
        class Vec2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            set(x, y) {
                this.x = x;
                this.y = y;
                return this;
            }

            lengthSq() {
                return this.x * this.x + this.y * this.y;
            }

            length() {
                return Math.sqrt(this.lengthSq());
            }

            normalize() {
                const len = this.length();
                if (len > 0) {
                    this.x /= len;
                    this.y /= len;
                }
                return this;
            }
        }

        /**
         * Vec2 Object Pool
         */
        class Vec2Pool {
            constructor(initialSize = 1000) {
                this.pool = new Array(initialSize);
                for (let i = 0; i < initialSize; i++) {
                    this.pool[i] = new Vec2();
                }
                this.used = 0;
                this.maxSize = 5000;
            }

            acquire(x = 0, y = 0) {
                if (this.used >= this.pool.length) {
                    if (this.pool.length < this.maxSize) {
                        this.pool.push(new Vec2(x, y));
                    } else {
                        this.used = 0;
                    }
                }
                const vec = this.pool[this.used++];
                vec.x = x;
                vec.y = y;
                return vec;
            }

            release() {
                if (this.used > 0) this.used--;
            }

            releaseAll() {
                this.used = 0;
            }

            getStats() {
                return {
                    used: this.used,
                    available: this.pool.length - this.used,
                    total: this.pool.length
                };
            }
        }

        const vec2Pool = new Vec2Pool(1000);

        /**
         * Optimized particle system
         */
        const createParticleSystem = (maxParticles) => {
            const positions = new Float32Array(maxParticles * 2);
            const velocities = new Float32Array(maxParticles * 2);
            const lifetimes = new Float32Array(maxParticles);
            const maxLifetimes = new Float32Array(maxParticles);
            const sizes = new Float32Array(maxParticles);
            
            let count = 0;
            
            const spawn = (x, y, vx, vy, lifetime, size) => {
                if (count >= maxParticles) {
                    count = Math.floor(maxParticles * 0.9);
                }
                
                const idx = count++;
                const idx2 = idx * 2;
                
                positions[idx2] = x;
                positions[idx2 + 1] = y;
                velocities[idx2] = vx;
                velocities[idx2 + 1] = vy;
                lifetimes[idx] = lifetime;
                maxLifetimes[idx] = lifetime;
                sizes[idx] = size;
                
                return idx;
            };
            
            const update = (dt, gravity = 0, width = 0, height = 0) => {
                let writeIdx = 0;
                
                for (let i = 0; i < count; i++) {
                    const idx2 = i * 2;
                    
                    velocities[idx2 + 1] += gravity * dt;
                    positions[idx2] += velocities[idx2] * dt;
                    positions[idx2 + 1] += velocities[idx2 + 1] * dt;
                    
                    if (width > 0 && height > 0) {
                        if (positions[idx2] < 0 || positions[idx2] > width ||
                            positions[idx2 + 1] < 0 || positions[idx2 + 1] > height) {
                            lifetimes[i] = 0;
                        }
                    }
                    
                    lifetimes[i] -= dt;
                    
                    if (lifetimes[i] <= 0) continue;
                    
                    if (i !== writeIdx) {
                        const wi2 = writeIdx * 2;
                        positions[wi2] = positions[idx2];
                        positions[wi2 + 1] = positions[idx2 + 1];
                        velocities[wi2] = velocities[idx2];
                        velocities[wi2 + 1] = velocities[idx2 + 1];
                        lifetimes[writeIdx] = lifetimes[i];
                        maxLifetimes[writeIdx] = maxLifetimes[i];
                        sizes[writeIdx] = sizes[i];
                    }
                    
                    writeIdx++;
                }
                
                count = writeIdx;
            };
            
            return Object.freeze({
                spawn,
                update,
                getCount: () => count,
                getPositions: () => positions,
                getVelocities: () => velocities,
                getLifetimes: () => lifetimes,
                getMaxLifetimes: () => maxLifetimes,
                getSizes: () => sizes,
                clear: () => { count = 0; }
            });
        };

        /**
         * High-performance throttle
         */
        const throttle = (fn, delay) => {
            let lastCall = 0;
            return (...args) => {
                const now = performance.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    fn(...args);
                }
            };
        };

        /**
         * RAF-based debounce
         */
        const rafDebounce = (fn) => {
            let rafId = null;
            return (...args) => {
                if (rafId !== null) cancelAnimationFrame(rafId);
                rafId = requestAnimationFrame(() => {
                    rafId = null;
                    fn(...args);
                });
            };
        };

        /**
         * Canvas renderer
         */
        const createRenderer = (canvasId, options = {}) => {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return null;
            
            const ctx = canvas.getContext('2d', {
                alpha: options.alpha ?? true,
                desynchronized: true,
                willReadFrequently: false
            });
            
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            
            const resize = () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;
                
                ctx.scale(dpr, dpr);
                
                return { width, height };
            };
            
            const clear = () => {
                ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
            };
            
            return Object.freeze({
                canvas,
                ctx,
                resize,
                clear,
                getDimensions: () => ({
                    width: canvas.width / dpr,
                    height: canvas.height / dpr
                })
            });
        };

        /**
         * Wish messages for lanterns
         */
        const WISH_MESSAGES = [
            "May this year bring you the friendships you deserve üíú",
            "You are stronger than you know, Eva ‚ú®",
            "Here's to new beginnings and brighter days üåü",
            "Your resilience is inspiring‚Äînever forget that üåô",
            "May you find joy in unexpected places üé®",
            "You matter, and your story is still being written üìñ",
            "Wishing you moments of peace and clarity üïäÔ∏è",
            "May kindness find you in surprising ways üå∏",
            "Here's to your courage and your journey ü¶ã",
            "You're not alone‚Äîbetter days are coming üåà"
        ];

        /**
         * Show wish message popup
         */
        function showWishMessage(message) {
            const popup = document.getElementById('wishMessage');
            const text = document.getElementById('wishMessageText');
            
            text.textContent = message;
            popup.classList.add('show');
        }

        /**
         * Close wish message popup
         */
        function closeWishMessage() {
            const popup = document.getElementById('wishMessage');
            popup.classList.remove('show');
        }

        window.closeWishMessage = closeWishMessage;

        // ============================================================
        // MAIN APPLICATION
        // ============================================================

        const CosmicBirthday = (() => {
            const state = createState({
                mouseX: window.innerWidth / 2,
                mouseY: window.innerHeight / 2,
                scrollProgress: 0,
                time: 0,
                isPlaying: false,
                canvasReady: false,
                isPaused: false,
                reductionFactor: 1.0,
                cakeLit: false,
                candlesLit: 0
            });
            
            const renderers = new Map();
            
            const sparkles = createParticleSystem(500);
            const trails = createParticleSystem(300);
            const orbs = createParticleSystem(50);
            
            const STAR_COUNT = 200;
            const stars = new Float32Array(STAR_COUNT * 5);
            const orbVelocities = new Float32Array(50 * 2);
            
            // Lantern system
            const MAX_LANTERNS = 8;
            const lanterns = new Float32Array(MAX_LANTERNS * 7); // x, y, vx, vy, size, hue, phase
            let lanternCount = 0;
            const usedWishes = new Set();
            
            // Cake system
            const CANDLE_COUNT = 19;
            const candles = new Array(CANDLE_COUNT);
            let cakeReady = false;
            
            const initStars = () => {
                for (let i = 0; i < STAR_COUNT; i++) {
                    const idx = i * 5;
                    stars[idx] = Math.random();
                    stars[idx + 1] = Math.random();
                    stars[idx + 2] = Math.random() * 2 + 0.5;
                    stars[idx + 3] = Math.random() * 0.0005 + 0.0001;
                    stars[idx + 4] = Math.random() * Math.PI * 2;
                }
            };
            
            const initRenderers = () => {
                const starRenderer = createRenderer('starCanvas', { alpha: false });
                if (starRenderer) {
                    starRenderer.resize();
                    renderers.set('starCanvas', starRenderer);
                }
                
                ['sparkleCanvas', 'trailCanvas', 'orbCanvas', 'lanternCanvas', 'cakeCanvas'].forEach(id => {
                    const renderer = createRenderer(id, { alpha: true });
                    if (renderer) {
                        renderer.resize();
                        renderers.set(id, renderer);
                    }
                });
                
                updatePerfStat('renderMode', 'Optimized', 'good');
            };
            
            const renderStars = (dt) => {
                const renderer = renderers.get('starCanvas');
                if (!renderer) return;
                
                const { ctx } = renderer;
                const { width, height } = renderer.getDimensions();
                const currentState = state.get();
                
                renderer.clear();
                
                const gradient = ctx.createRadialGradient(
                    currentState.mouseX, currentState.mouseY, 0,
                    width / 2, height / 2, width
                );
                gradient.addColorStop(0, `rgba(138, 43, 226, ${0.02 + currentState.scrollProgress * 0.03})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                ctx.fillStyle = 'white';
                ctx.beginPath();
                
                for (let i = 0; i < STAR_COUNT; i++) {
                    const idx = i * 5;
                    const x = stars[idx] * width;
                    const y = stars[idx + 1] * height;
                    const size = stars[idx + 2];
                    const phase = stars[idx + 4];
                    
                    const parallax = size > 1 ? 0.5 : 0.3;
                    const offsetX = (currentState.mouseX / width - 0.5) * parallax * 50;
                    const offsetY = (currentState.mouseY / height - 0.5) * parallax * 50;
                    
                    const brightness = Math.sin(phase) * 0.5 + 0.5;
                    ctx.globalAlpha = brightness * 0.8 + 0.2;
                    
                    ctx.moveTo(x + offsetX + size, y + offsetY);
                    ctx.arc(x + offsetX, y + offsetY, size, 0, Math.PI * 2);
                    
                    stars[idx + 4] += stars[idx + 3] * dt * 1000;
                }
                
                ctx.fill();
                ctx.globalAlpha = 1;
            };
            
            const createSparkles = (x, y) => {
                const currentState = state.get();
                const effectiveCount = Math.floor(5 * currentState.reductionFactor);
                
                for (let i = 0; i < effectiveCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 50 + 25;
                    
                    const vel = vec2Pool.acquire(
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed
                    );
                    
                    sparkles.spawn(x, y, vel.x, vel.y, Math.random() * 0.5 + 0.3, Math.random() * 3 + 1);
                    vec2Pool.release(vel);
                }
            };
            
            const renderSparkles = (dt) => {
                const { width, height } = renderers.get('starCanvas')?.getDimensions() || { width: window.innerWidth, height: window.innerHeight };
                
                sparkles.update(dt, 100, width, height);
                
                const renderer = renderers.get('sparkleCanvas');
                if (!renderer) return;
                
                const { ctx } = renderer;
                renderer.clear();
                
                const positions = sparkles.getPositions();
                const lifetimes = sparkles.getLifetimes();
                const maxLifetimes = sparkles.getMaxLifetimes();
                const sizes = sparkles.getSizes();
                const count = sparkles.getCount();
                
                for (let i = 0; i < count; i++) {
                    const idx2 = i * 2;
                    const x = positions[idx2];
                    const y = positions[idx2 + 1];
                    const life = lifetimes[i] / maxLifetimes[i];
                    const size = sizes[i];
                    
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${life})`);
                    gradient.addColorStop(0.5, `rgba(183, 148, 246, ${life * 0.5})`);
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x - size * 3, y - size * 3, size * 6, size * 6);
                }
            };
            
            const createTrail = (x, y) => {
                const currentState = state.get();
                if (Math.random() < currentState.reductionFactor) {
                    const vel = vec2Pool.acquire(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20
                    );
                    trails.spawn(x, y, vel.x, vel.y, 1.5, 2);
                    vec2Pool.release(vel);
                }
            };
            
            const renderTrails = (dt) => {
                const { width, height } = renderers.get('starCanvas')?.getDimensions() || { width: window.innerWidth, height: window.innerHeight };
                
                trails.update(dt, 0, width, height);
                
                const renderer = renderers.get('trailCanvas');
                if (!renderer) return;
                
                const { ctx } = renderer;
                renderer.clear();
                
                const positions = trails.getPositions();
                const lifetimes = trails.getLifetimes();
                const maxLifetimes = trails.getMaxLifetimes();
                const count = trails.getCount();
                
                ctx.globalCompositeOperation = 'lighter';
                
                for (let i = 0; i < count; i++) {
                    const idx2 = i * 2;
                    const x = positions[idx2];
                    const y = positions[idx2 + 1];
                    const life = lifetimes[i] / maxLifetimes[i];
                    
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, 8);
                    gradient.addColorStop(0, `rgba(183, 148, 246, ${life * 0.6})`);
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x - 8, y - 8, 16, 16);
                }
                
                ctx.globalCompositeOperation = 'source-over';
            };
            
            const initOrbs = () => {
                const { width, height } = renderers.get('starCanvas')?.getDimensions() || { width: window.innerWidth, height: window.innerHeight };
                
                orbs.clear();
                
                for (let i = 0; i < 30; i++) {
                    const pos = vec2Pool.acquire(Math.random() * width, Math.random() * height);
                    orbs.spawn(pos.x, pos.y, 0, 0, Infinity, Math.random() * 30 + 10);
                    vec2Pool.release(pos);
                    
                    const idx2 = i * 2;
                    orbVelocities[idx2] = (Math.random() - 0.5) * 20;
                    orbVelocities[idx2 + 1] = (Math.random() - 0.5) * 20;
                }
            };
            
            const renderOrbs = (dt) => {
                const { width, height } = renderers.get('starCanvas')?.getDimensions() || { width: window.innerWidth, height: window.innerHeight };
                const currentState = state.get();
                
                const positions = orbs.getPositions();
                const sizes = orbs.getSizes();
                const count = orbs.getCount();
                
                const mousePos = vec2Pool.acquire(currentState.mouseX, currentState.mouseY);
                
                for (let i = 0; i < count; i++) {
                    const idx2 = i * 2;
                    
                    const dx = mousePos.x - positions[idx2];
                    const dy = mousePos.y - positions[idx2 + 1];
                    const distSq = dx * dx + dy * dy;
                    const threshold = 200 * 200;
                    
                    if (distSq > 0 && distSq < threshold) {
                        const force = (threshold - distSq) / (threshold * 10);
                        orbVelocities[idx2] += dx * force;
                        orbVelocities[idx2 + 1] += dy * force;
                    }
                    
                    orbVelocities[idx2] *= 0.98;
                    orbVelocities[idx2 + 1] *= 0.98;
                    
                    positions[idx2] += orbVelocities[idx2] * dt;
                    positions[idx2 + 1] += orbVelocities[idx2 + 1] * dt;
                    
                    const size = sizes[i];
                    if (positions[idx2] < -size) {
                        positions[idx2] = width + size;
                        orbVelocities[idx2] *= 0.5;
                    }
                    if (positions[idx2] > width + size) {
                        positions[idx2] = -size;
                        orbVelocities[idx2] *= 0.5;
                    }
                    if (positions[idx2 + 1] < -size) {
                        positions[idx2 + 1] = height + size;
                        orbVelocities[idx2 + 1] *= 0.5;
                    }
                    if (positions[idx2 + 1] > height + size) {
                        positions[idx2 + 1] = -size;
                        orbVelocities[idx2 + 1] *= 0.5;
                    }
                }
                
                vec2Pool.release(mousePos);
                
                const renderer = renderers.get('orbCanvas');
                if (!renderer) return;
                
                const { ctx } = renderer;
                renderer.clear();
                
                ctx.globalCompositeOperation = 'lighter';
                
                const hue = 270 + Math.sin(currentState.time * 2) * 30;
                
                for (let i = 0; i < count; i++) {
                    const idx2 = i * 2;
                    const x = positions[idx2];
                    const y = positions[idx2 + 1];
                    const size = sizes[i];
                    const orbHue = hue + i * 5;
                    
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                    gradient.addColorStop(0, `hsla(${orbHue}, 70%, 60%, 0.3)`);
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x - size, y - size, size * 2, size * 2);
                }
                
                ctx.globalCompositeOperation = 'source-over';
            };
            
            // ============================================================
            // WISH LANTERNS FEATURE
            // ============================================================
            
            const spawnLantern = () => {
                if (lanternCount >= MAX_LANTERNS) return;
                
                const { width, height } = renderers.get('starCanvas')?.getDimensions() || { width: window.innerWidth, height: window.innerHeight };
                
                const idx = lanternCount * 7;
                lanterns[idx] = -50; // x
                lanterns[idx + 1] = Math.random() * height * 0.8 + height * 0.1; // y
                lanterns[idx + 2] = 30 + Math.random() * 20; // vx
                lanterns[idx + 3] = (Math.random() - 0.5) * 10; // vy
                lanterns[idx + 4] = 25 + Math.random() * 15; // size
                lanterns[idx + 5] = Math.random() * 60 + 20; // hue
                lanterns[idx + 6] = Math.random() * Math.PI * 2; // phase
                
                lanternCount++;
            };
            
            const updateLanterns = (dt) => {
                const { width } = renderers.get('starCanvas')?.getDimensions() || { width: window.innerWidth, height: window.innerHeight };
                const currentTime = state.get().time;
                
                let writeIdx = 0;
                
                for (let i = 0; i < lanternCount; i++) {
                    const idx = i * 7;
                    
                    lanterns[idx] += lanterns[idx + 2] * dt;
                    lanterns[idx + 1] += lanterns[idx + 3] * dt;
                    lanterns[idx + 1] += Math.sin(currentTime * 2 + lanterns[idx + 6]) * 0.5;
                    lanterns[idx + 6] += dt * 0.5;
                    
                    if (lanterns[idx] > width + 100) {
                        continue;
                    }
                    
                    if (i !== writeIdx) {
                        const writeId = writeIdx * 7;
                        for (let j = 0; j < 7; j++) {
                            lanterns[writeId + j] = lanterns[idx + j];
                        }
                    }
                    
                    writeIdx++;
                }
                
                lanternCount = writeIdx;
            };
            
            const renderLanterns = () => {
                const renderer = renderers.get('lanternCanvas');
                if (!renderer) return;
                
                const { ctx } = renderer;
                renderer.clear();
                
                const currentTime = state.get().time;
                
                for (let i = 0; i < lanternCount; i++) {
                    const idx = i * 7;
                    const x = lanterns[idx];
                    const y = lanterns[idx + 1];
                    const size = lanterns[idx + 4];
                    const hue = lanterns[idx + 5];
                    const phase = lanterns[idx + 6];
                    
                    const glow = Math.sin(currentTime * 3 + phase) * 0.3 + 0.7;
                    
                    // Lantern body
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                    gradient.addColorStop(0, `hsla(${hue}, 80%, 70%, ${0.8 * glow})`);
                    gradient.addColorStop(0.5, `hsla(${hue}, 70%, 60%, ${0.5 * glow})`);
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Lantern core
                    ctx.fillStyle = `hsla(${hue}, 90%, 80%, ${0.9 * glow})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Decorative lines
                    ctx.strokeStyle = `hsla(${hue}, 70%, 50%, ${0.4 * glow})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x - size, y);
                    ctx.lineTo(x + size, y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x, y - size);
                    ctx.lineTo(x, y + size);
                    ctx.stroke();
                }
            };
            
            const handleLanternClick = (x, y) => {
                for (let i = 0; i < lanternCount; i++) {
                    const idx = i * 7;
                    const lx = lanterns[idx];
                    const ly = lanterns[idx + 1];
                    const size = lanterns[idx + 4];
                    
                    const dx = x - lx;
                    const dy = y - ly;
                    const distSq = dx * dx + dy * dy;
                    
                    if (distSq < size * size) {
                        // Get random unused wish
                        const availableWishes = WISH_MESSAGES.filter((_, i) => !usedWishes.has(i));
                        if (availableWishes.length === 0) {
                            usedWishes.clear();
                        }
                        
                        const wishIndex = WISH_MESSAGES.findIndex(w => 
                            w === availableWishes[Math.floor(Math.random() * availableWishes.length)]
                        );
                        
                        usedWishes.add(wishIndex);
                        showWishMessage(WISH_MESSAGES[wishIndex]);
                        
                        // Create sparkle effect
                        for (let j = 0; j < 15; j++) {
                            createSparkles(lx, ly);
                        }
                        
                        // Remove lantern
                        for (let j = idx; j < lanternCount * 7 - 7; j++) {
                            lanterns[j] = lanterns[j + 7];
                        }
                        lanternCount--;
                        
                        return true;
                    }
                }
                return false;
            };
            
            // ============================================================
            // BIRTHDAY CAKE FEATURE
            // ============================================================
            
            const initCake = () => {
                const container = document.getElementById('cakeContainer');
                if (!container) return;
                
                const canvas = document.getElementById('cakeCanvas');
                if (!canvas) return;
                
                const rect = container.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const radius = 80;
                const angleStep = (Math.PI * 1.5) / (CANDLE_COUNT - 1);
                const startAngle = Math.PI * 0.75;
                
                for (let i = 0; i < CANDLE_COUNT; i++) {
                    const angle = startAngle + i * angleStep;
                    candles[i] = {
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius - 30,
                        lit: false,
                        phase: Math.random() * Math.PI * 2
                    };
                }
                
                cakeReady = true;
            };
            
            const renderCake = (dt) => {
                const renderer = renderers.get('cakeCanvas');
                if (!renderer || !cakeReady) return;
                
                const { ctx } = renderer;
                const currentState = state.get();
                const currentTime = currentState.time;
                
                renderer.clear();
                
                const container = document.getElementById('cakeContainer');
                if (!container) return;
                
                const rect = container.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                // Draw cake base
                const cakeGradient = ctx.createLinearGradient(centerX, centerY - 50, centerX, centerY + 50);
                cakeGradient.addColorStop(0, '#ff6b9d');
                cakeGradient.addColorStop(0.5, '#b794f6');
                cakeGradient.addColorStop(1, '#9f7aea');
                
                ctx.fillStyle = cakeGradient;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY + 50, 100, 20, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillRect(centerX - 100, centerY - 20, 200, 70);
                
                ctx.fillStyle = '#ffd89b';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY - 20, 100, 20, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Decorative frosting
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * 85;
                    const y = centerY + 15;
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw candles
                let litCount = 0;
                for (let i = 0; i < CANDLE_COUNT; i++) {
                    const candle = candles[i];
                    
                    // Candle stick
                    ctx.fillStyle = candle.lit ? '#ffe4b5' : '#f5deb3';
                    ctx.fillRect(candle.x - 3, candle.y, 6, 25);
                    
                    // Wick
                    ctx.strokeStyle = candle.lit ? '#ff6347' : '#333';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(candle.x, candle.y);
                    ctx.lineTo(candle.x, candle.y - 5);
                    ctx.stroke();
                    
                    if (candle.lit) {
                        litCount++;
                        candle.phase += dt * 5;
                        
                        // Flame
                        const flicker = Math.sin(candle.phase) * 2;
                        const flameY = candle.y - 10 + flicker;
                        
                        const flameGradient = ctx.createRadialGradient(
                            candle.x, flameY, 0,
                            candle.x, flameY, 8
                        );
                        flameGradient.addColorStop(0, '#fff');
                        flameGradient.addColorStop(0.3, '#ffed4e');
                        flameGradient.addColorStop(0.7, '#ff6b35');
                        flameGradient.addColorStop(1, 'transparent');
                        
                        ctx.fillStyle = flameGradient;
                        ctx.beginPath();
                        ctx.arc(candle.x, flameY, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Glow
                        const glowGradient = ctx.createRadialGradient(
                            candle.x, flameY, 0,
                            candle.x, flameY, 20
                        );
                        glowGradient.addColorStop(0, 'rgba(255, 237, 78, 0.4)');
                        glowGradient.addColorStop(1, 'transparent');
                        
                        ctx.fillStyle = glowGradient;
                        ctx.beginPath();
                        ctx.arc(candle.x, flameY, 20, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                state.update({ candlesLit: litCount });
            };
            
            const handleCakeClick = (x, y) => {
                if (!cakeReady) return false;
                
                const currentState = state.get();
                
                // Check if all candles are lit and clicking to blow out
                if (currentState.candlesLit === CANDLE_COUNT) {
                    const allLit = candles.every(c => c.lit);
                    if (allLit) {
                        // Blow out animation
                        candles.forEach(c => c.lit = false);
                        
                        // Create massive sparkle effect
                        for (let i = 0; i < 50; i++) {
                            const container = document.getElementById('cakeContainer');
                            const rect = container.getBoundingClientRect();
                            const cx = rect.left + rect.width / 2;
                            const cy = rect.top + rect.height / 2;
                            createSparkles(cx + (Math.random() - 0.5) * 200, cy + (Math.random() - 0.5) * 100);
                        }
                        
                        showWishMessage("üéÇ Happy Birthday, Eva! May all your wishes come true! üéÇ");
                        return true;
                    }
                }
                
                // Check candle clicks
                for (let i = 0; i < CANDLE_COUNT; i++) {
                    const candle = candles[i];
                    const dx = x - candle.x;
                    const dy = y - (candle.y - 5);
                    const distSq = dx * dx + dy * dy;
                    
                    if (distSq < 400) { // 20px radius
                        candle.lit = !candle.lit;
                        createSparkles(candle.x, candle.y - 10);
                        return true;
                    }
                }
                
                return false;
            };
            
            const autoOptimize = () => {
                const avgFPS = PerfMonitor.getAvgFPS();
                const currentReduction = state.get().reductionFactor;
                let newReduction = currentReduction;
                
                if (avgFPS < 35) {
                    newReduction = Math.max(0.3, currentReduction - 0.15);
                } else if (avgFPS > 55 && currentReduction < 1) {
                    newReduction = Math.min(1, currentReduction + 0.05);
                }
                
                if (newReduction !== currentReduction) {
                    state.update({ reductionFactor: newReduction });
                    
                    if (newReduction < 1) {
                        const sparkleLifetimes = sparkles.getLifetimes();
                        const trailLifetimes = trails.getLifetimes();
                        
                        const cullCount = Math.floor(50 * (1 - newReduction));
                        for (let i = 0; i < cullCount; i++) {
                            if (i < sparkleLifetimes.length) sparkleLifetimes[i] = 0;
                            if (i < trailLifetimes.length) trailLifetimes[i] = 0;
                        }
                    }
                    
                    updatePerfStat('reductionFactor', newReduction.toFixed(2), 
                        newReduction >= 0.9 ? 'good' : newReduction >= 0.6 ? 'value' : 'warning');
                }
            };
            
            const handleMouseMove = throttle((e) => {
                const x = e.clientX;
                const y = e.clientY;
                
                state.update({ mouseX: x, mouseY: y });
                
                document.documentElement.style.setProperty('--mouse-x', `${(x / window.innerWidth) * 100}%`);
                document.documentElement.style.setProperty('--mouse-y', `${(y / window.innerHeight) * 100}%`);
                
                if (Math.random() > 0.7) {
                    createSparkles(x, y);
                }
                createTrail(x, y);
            }, 16);
            
            const handleClick = (e) => {
                const x = e.clientX;
                const y = e.clientY;
                
                // Check cake click first
                if (handleCakeClick(x, y)) {
                    return;
                }
                
                // Check lantern click
                if (handleLanternClick(x, y)) {
                    return;
                }
                
                // Regular sparkles
                createSparkles(x, y);
            };
            
            const handleScroll = rafDebounce(() => {
                const scrolled = window.pageYOffset;
                const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
                const progress = maxScroll > 0 ? Math.min(scrolled / maxScroll, 1) : 0;
                
                state.update({ scrollProgress: progress });
                
                document.documentElement.style.setProperty('--scroll-progress', progress);
                document.documentElement.style.setProperty('--hue-shift', progress * 20);
            });
            
            const handleResize = rafDebounce(() => {
                state.update({ isPaused: true });
                
                const oldDims = renderers.get('starCanvas')?.getDimensions();
                
                renderers.forEach(renderer => renderer.resize());
                
                const newDims = renderers.get('starCanvas')?.getDimensions();
                if (oldDims && newDims) {
                    const scaleX = newDims.width / oldDims.width;
                    const scaleY = newDims.height / oldDims.height;
                    
                    const orbPos = orbs.getPositions();
                    const orbCount = orbs.getCount();
                    for (let i = 0; i < orbCount; i++) {
                        orbPos[i * 2] *= scaleX;
                        orbPos[i * 2 + 1] *= scaleY;
                    }
                }
                
                if (cakeReady) {
                    initCake();
                }
                
                setTimeout(() => state.update({ isPaused: false }), 100);
            });
            
            const setupIntersectionObserver = () => {
                const observer = new IntersectionObserver(
                    (entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                entry.target.classList.add('visible');
                            }
                        });
                    },
                    { threshold: [0.1, 0.5], rootMargin: '0px' }
                );
                
                ['#letter', '#birthdayWishes'].forEach(selector => {
                    const el = document.querySelector(selector);
                    if (el) observer.observe(el);
                });
            };
            
            const setupAudioErrorHandling = () => {
                const audio = document.getElementById('bgMusic');
                if (audio) {
                    audio.onerror = function() {
                        const audioBars = document.querySelectorAll('.audio-bar');
                        audioBars.forEach(bar => bar.classList.remove('playing'));
                        
                        const subtitle = document.querySelector('.audio-subtitle');
                        if (subtitle) {
                            subtitle.textContent = '(Audio unavailable)';
                            subtitle.style.color = 'rgba(255, 100, 100, 0.7)';
                        }
                    };
                }
            };
            
            let lastTime = performance.now();
            let animationId = null;
            let frameSkipCount = 0;
            let lanternSpawnTimer = 0;
            
            const animate = (currentTime) => {
                animationId = requestAnimationFrame(animate);
                
                const dt = Math.min((currentTime - lastTime) / 1000, 0.1);
                lastTime = currentTime;
                
                PerfMonitor.update();
                
                if (frameSkipCount++ % 30 === 0) {
                    autoOptimize();
                    
                    const totalParticles = sparkles.getCount() + trails.getCount() + orbs.getCount() + lanternCount;
                    updatePerfStat('particleCount', totalParticles);
                    
                    const poolStats = vec2Pool.getStats();
                    updatePerfStat('poolStats', `${poolStats.used}/${poolStats.total}`);
                    
                    updatePerfStat('memUsage', getMemoryUsage());
                }
                
                const fps = PerfMonitor.getFPS();
                if (fps < 25 && frameSkipCount % 2 === 0) return;
                
                if (state.get().isPaused) return;
                
                state.update(s => ({ time: s.time + dt }));
                
                // Spawn lanterns periodically
                lanternSpawnTimer += dt;
                if (lanternSpawnTimer > 3 && lanternCount < MAX_LANTERNS) {
                    spawnLantern();
                    lanternSpawnTimer = 0;
                }
                
                renderStars(dt);
                renderSparkles(dt);
                renderTrails(dt);
                renderOrbs(dt);
                
                updateLanterns(dt);
                renderLanterns();
                
                renderCake(dt);
                
                if (frameSkipCount % 60 === 0) {
                    vec2Pool.releaseAll();
                }
            };
            
            const startExperience = async () => {
                const entryOverlay = document.getElementById('entryOverlay');
                const mainContainer = document.getElementById('mainContainer');
                const bgMusic = document.getElementById('bgMusic');
                const audioBars = document.querySelectorAll('.audio-bar');
                
                entryOverlay.classList.add('hidden');
                
                ['starCanvas', 'sparkleCanvas', 'trailCanvas', 'orbCanvas', 'lanternCanvas', 'cakeCanvas'].forEach(id => {
                    const canvas = document.getElementById(id);
                    if (canvas) canvas.classList.add('visible');
                });
                
                if (bgMusic) {
                    try {
                        await bgMusic.play();
                        state.update({ isPlaying: true });
                        audioBars.forEach(bar => bar.classList.add('playing'));
                    } catch (e) {
                        const retryPlay = () => {
                            bgMusic.play()
                                .then(() => {
                                    state.update({ isPlaying: true });
                                    audioBars.forEach(bar => bar.classList.add('playing'));
                                })
                                .catch(() => {});
                        };
                        
                        document.addEventListener('click', retryPlay, { once: true, passive: true });
                        document.addEventListener('touchstart', retryPlay, { once: true, passive: true });
                    }
                }
                
                setTimeout(() => {
                    mainContainer.classList.add('visible');
                    setupIntersectionObserver();
                    initCake();
                }, 500);
                
                animationId = requestAnimationFrame(animate);
            };
            
            const init = () => {
                initStars();
                initRenderers();
                initOrbs();
                
                document.addEventListener('mousemove', handleMouseMove, { passive: true });
                document.addEventListener('click', handleClick, { passive: true });
                window.addEventListener('scroll', handleScroll, { passive: true });
                window.addEventListener('resize', handleResize);
                
                const enterBtn = document.querySelector('.enter-button');
                if (enterBtn) {
                    enterBtn.addEventListener('click', startExperience);
                }
                
                setupAudioErrorHandling();
                
                state.update({ canvasReady: true });
            };
            
            const cleanup = () => {
                if (animationId) cancelAnimationFrame(animationId);
                vec2Pool.releaseAll();
            };
            
            window.addEventListener('beforeunload', cleanup);
            
            return Object.freeze({
                init,
                getState: () => state.get(),
                cleanup
            });
        })();

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', CosmicBirthday.init);
        } else {
            CosmicBirthday.init();
        }
    </script>
</body>
</html>
